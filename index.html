<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bruh subs</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%;
    }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      font-family: 'Inter', Arial, sans-serif;
      background: linear-gradient(135deg, #fff3e0 0%, #ffe0e0 100%);
      margin: 0;
      padding: 0;
      position: relative;
      overflow-x: hidden;
    }
    .bg-shape1 {
      position: absolute;
      top: -120px;
      left: -120px;
      width: 320px;
      height: 320px;
      background: radial-gradient(circle at 60% 40%, #ff9800 0%, #ff7043 80%);
      opacity: 0.18;
      border-radius: 50%;
      z-index: 0;
    }
    .bg-shape2 {
      position: absolute;
      bottom: -100px;
      right: -100px;
      width: 260px;
      height: 260px;
      background: radial-gradient(circle at 40% 60%, #ff5252 0%, #ff9800 90%);
      opacity: 0.15;
      border-radius: 50%;
      z-index: 0;
    }
    .main-container {
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      border-radius: 28px;
      box-shadow: 0 8px 32px 0 rgba(255, 112, 67, 0.10);
      padding: 48px 38px 38px 38px;
      text-align: center;
      position: relative;
      z-index: 1;
      flex: 1 0 auto;
      padding-top: 48px;
      padding-bottom: 0;
    }
    h1 {
      font-size: 2.6rem;
      margin-bottom: 10px;
      color: #ff7043;
      font-weight: 800;
      letter-spacing: -1.5px;
      text-shadow: 0 2px 8px rgba(255, 112, 67, 0.08);
    }
    .subtitle {
      color: #ff9800;
      margin-bottom: 32px;
      font-size: 1.18rem;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .effect-list {
      display: grid;
      grid-template-columns: repeat(2, 260px);
      gap: 32px 32px;
      margin-bottom: 10px;
      justify-content: center;
      align-items: center;
    }
    .effect-btn {
      width: 260px;
      height: 90px;
      text-align: center;
      word-break: break-word;
      padding: 0 12px;
      border: none;
      border-radius: 14px;
      background: linear-gradient(90deg, #ff7043 60%, #ff9800 100%);
      color: #fff;
      font-size: 1.18rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 12px rgba(255, 112, 67, 0.10);
      letter-spacing: 0.2px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .effect-btn:hover {
      background: linear-gradient(90deg, #ff9800 60%, #ff7043 100%);
    }
    .form-section {
      margin-top: 30px;
      text-align: left;
    }
    label {
      display: block;
      margin: 20px 0 7px 0;
      color: #ff7043;
      font-weight: 700;
      font-size: 1.08rem;
      letter-spacing: 0.1px;
    }
    input, select, textarea, button {
      width: 100%;
      padding: 14px;
      margin-bottom: 18px;
      border-radius: 12px;
      border: 1.5px solid #ffd6c2;
      font-size: 1.08rem;
      box-sizing: border-box;
      font-family: 'Inter', Arial, sans-serif;
      background: #fff7f0;
      transition: border 0.2s;
    }
    input:focus, select:focus, textarea:focus {
      border: 1.5px solid #ff7043;
      outline: none;
      background: #fff;
    }
    button.generate {
      background: linear-gradient(90deg, #ff7043 60%, #ff9800 100%);
      color: #fff;
      border: none;
      font-size: 1.18rem;
      font-weight: 700;
      cursor: pointer;
      margin-top: 10px;
      border-radius: 14px;
      box-shadow: 0 2px 12px rgba(255, 112, 67, 0.10);
      transition: background 0.2s, box-shadow 0.2s;
      letter-spacing: 0.2px;
    }
    button.generate:hover {
      background: linear-gradient(90deg, #ff9800 60%, #ff7043 100%);
    }
    textarea {
      height: 180px;
      resize: vertical;
      background: #fff7f0;
      border-radius: 12px;
      font-size: 1.08rem;
    }
    .back-btn {
      background: #ffe0b2;
      color: #ff7043;
      border: none;
      border-radius: 12px;
      padding: 12px 26px;
      font-size: 1.08rem;
      margin-bottom: 18px;
      cursor: pointer;
      font-weight: 700;
      transition: background 0.2s;
      letter-spacing: 0.1px;
    }
    .back-btn:hover {
      background: #ffd6c2;
    }
    #errorMsg {
      display: none;
      color: #fff;
      background: #ff5252;
      padding: 14px 22px;
      border-radius: 14px;
      margin-bottom: 18px;
      font-weight: 700;
      font-size: 1.08rem;
      box-shadow: 0 2px 8px rgba(255,82,82,0.10);
      letter-spacing: 0.2px;
    }
    #durationBarContainer {
      background: #fff3e0;
      border-radius: 16px;
      padding: 20px 20px 10px 20px;
      box-shadow: 0 2px 8px rgba(255, 112, 67, 0.06);
      margin-bottom: 28px;
    }
    #resolveBar {
      margin-top: 0;
      margin-bottom: 0;
    }
    #resolveBarBg {
      background: #ffe0b2;
    }
    #resolveBarEffect {
      background: linear-gradient(90deg, #ff7043 60%, #ff9800 100%);
      box-shadow: 0 2px 8px rgba(255, 112, 67, 0.10);
    }
    #handleStart, #handleEnd {
      background: #fff;
      border: 2.5px solid #ff7043;
      box-shadow: 0 2px 8px rgba(255, 112, 67, 0.10);
      transition: border 0.2s;
    }
    #handleStart:hover, #handleEnd:hover {
      border: 2.5px solid #ff9800;
    }
    #effectTooltip {
      background: #ff7043;
      color: #fff;
      font-size: 1.08rem;
      font-weight: 700;
      border-radius: 10px;
      padding: 7px 18px;
      box-shadow: 0 2px 8px rgba(255, 112, 67, 0.10);
      letter-spacing: 0.2px;
    }
    .footer {
      width: 100%;
      text-align: center;
      padding: 22px 0 12px 0;
      color: #fff;
      font-size: 1.12rem;
      font-weight: 700;
      letter-spacing: 0.2px;
      background: linear-gradient(90deg, #ff7043 60%, #ff9800 100%);
      border-radius: 0;
      margin: 0;
      box-shadow: 0 -2px 12px rgba(255, 112, 67, 0.10);
      flex-shrink: 0;
    }
    /* Responsive */
    @media (max-width: 700px) {
      .main-container {
        max-width: 98vw;
        padding: 18px 4vw 18px 4vw;
      }
      #durationBarContainer {
        padding: 12px 4vw 8px 4vw;
      }
      .footer {
        font-size: 1rem;
        padding: 22px 0 12px 0;
        border-radius: 0 0 16px 16px;
      }
      .effect-list {
        grid-template-columns: 1fr;
        gap: 18px;
        justify-content: center;
      }
      .effect-btn {
        width: 100%;
        max-width: 98vw;
        min-width: 0;
        height: 70px;
        font-size: 1.08rem;
      }
    }
    .slide-in {
      animation: slideIn 0.7s cubic-bezier(.2,1.8,.5,1.1);
    }
    @keyframes slideIn {
      0% { opacity: 0; transform: translateY(40px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .fade-in {
      animation: fadeIn 0.6s cubic-bezier(.2,1.8,.5,1.1);
    }
    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    body.dark {
      background: #18191d !important;
    }
    .main-container.dark {
      background: #23242a !important;
      box-shadow: 0 8px 32px 0 rgba(0,0,0,0.18) !important;
    }
    .footer.dark {
      background: linear-gradient(90deg,#ff7043 60%,#ff9800 100%) !important;
      color: #fff !important;
    }
    input.dark, select.dark, textarea.dark {
      background: #23242a !important;
      color: #fff !important;
      border-color: #444 !important;
    }
    #output.dark {
      background: #18191d !important;
      color: #fff !important;
    }
    #durationBarContainer.dark {
      background: #18191d !important;
    }
    #resolveBarBg.dark {
      background: #333 !important;
    }
    .ripple {
      position: relative;
      overflow: hidden;
    }
    .ripple-effect {
      position: absolute;
      border-radius: 50%;
      transform: scale(0);
      animation: ripple 0.6s linear;
      background: rgba(255,152,0,0.25);
      pointer-events: none;
      z-index: 2;
    }
    @keyframes ripple {
      to {
        transform: scale(2.5);
        opacity: 0;
      }
    }
    .output-highlight {
      animation: outputHighlight 0.7s cubic-bezier(.2,1.8,.5,1.1);
      background: linear-gradient(90deg, #ff9800 0%, #ff7043 100%);
      color: #fff !important;
    }
    @keyframes outputHighlight {
      0% { background: transparent; color: inherit; }
      30% { background: linear-gradient(90deg, #ff9800 0%, #ff7043 100%); color: #fff; }
      100% { background: transparent; color: inherit; }
    }
    .copied-anim {
      position: absolute;
      right: 24px;
      top: -36px;
      font-size: 1.1rem;
      color: #ff9800;
      background: #fff;
      border-radius: 8px;
      padding: 4px 16px;
      box-shadow: 0 2px 8px rgba(255,112,67,0.10);
      opacity: 0;
      pointer-events: none;
      animation: copiedFade 1.2s cubic-bezier(.2,1.8,.5,1.1);
    }
    @keyframes copiedFade {
      0% { opacity: 0; transform: translateY(10px); }
      20% { opacity: 1; transform: translateY(0); }
      80% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-10px); }
    }
    .slide-out {
      animation: slideOut 0.5s cubic-bezier(.2,1.8,.5,1.1) forwards;
    }
    @keyframes slideOut {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(40px); }
    }
    .bg-fade {
      transition: background 0.5s cubic-bezier(.2,1.8,.5,1.1), color 0.5s cubic-bezier(.2,1.8,.5,1.1);
    }
    .main-container, .footer {
      transition: background 0.5s cubic-bezier(.2,1.8,.5,1.1), color 0.5s cubic-bezier(.2,1.8,.5,1.1), box-shadow 0.5s cubic-bezier(.2,1.8,.5,1.1);
    }
    .main-container.slide-in {
      animation: slideIn 0.7s cubic-bezier(.2,1.8,.5,1.1);
    }
    .main-container.slide-out {
      animation: slideOut 0.5s cubic-bezier(.2,1.8,.5,1.1) forwards;
    }
    .coloranim-preview {
      background: #fff7f0;
      border-radius: 12px;
      padding: 12px 18px;
      margin-bottom: 16px;
      font-size: 1.25rem;
      font-weight: bold;
      min-height: 38px;
      color: #222b45;
      transition: background 0.4s, color 0.4s;
    }
    .coloranim-output {
      background: #f7fafd;
      border-radius: 12px;
      padding: 14px 18px;
      font-family: monospace;
      font-size: 1.04rem;
      color: #222b45;
      border: 1.5px solid #e3eaf2;
      min-height: 120px;
      margin-bottom: 8px;
      white-space: pre-wrap;
      word-break: break-all;
      overflow-wrap: anywhere;
      transition: background 0.4s, color 0.4s;
    }
    .dark .coloranim-preview {
      background: #23242a;
      color: #fff;
    }
    .dark .coloranim-output {
      background: #18191d;
      color: #fff;
      border-color: #333;
    }
    .coloranim-btns {
      display: flex;
      gap: 12px;
      margin-bottom: 10px;
    }
    .coloranim-btns .generate {
      flex: 1 1 0;
      min-width: 0;
      max-width: 100%;
      margin: 0;
      height: 48px;
      font-size: 1.13rem;
    }
    /* Custom tooltip for effect buttons */
    .effect-btn[data-tooltip] {
      position: relative;
    }
    .effect-btn[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translateY(-50%) translateX(18px);
      background: linear-gradient(90deg, #fff7f0 60%, #ffe0e0 100%);
      color: #ff7043;
      font-size: 1.08rem;
      font-weight: 600;
      padding: 12px 22px;
      border-radius: 14px;
      box-shadow: 0 4px 18px 0 rgba(255, 112, 67, 0.13);
      border: 1.5px solid #ffd6c2;
      white-space: pre-line;
      z-index: 9999;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.2s;
      max-width: 320px;
      min-width: 180px;
      width: max-content;
      overflow-wrap: break-word;
      text-align: left;
    }
    /* Dark mode for tooltip (must come after the above) */
    body.dark .effect-btn[data-tooltip]:hover::after {
      background: linear-gradient(90deg, #23242a 60%, #18191d 100%) !important;
      color: #ff9800 !important;
      border: 1.5px solid #444 !important;
      box-shadow: 0 4px 18px 0 rgba(0,0,0,0.18) !important;
      z-index: 9999 !important;
    }
    .effect-btn[data-tooltip]:hover::before,
    .effect-btn[data-tooltip]::before {
      display: none !important;
    }
    body.dark .effect-btn[data-tooltip]:hover::before,
    body.dark .effect-btn[data-tooltip]::before {
      display: none !important;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 56px;
      height: 32px;
      vertical-align: middle;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, #ffe0b2 60%, #ffd6c2 100%);
      border-radius: 32px;
      transition: background 0.3s;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 6px;
    }
    .slider .icon {
      font-size: 1.3rem;
      transition: transform 0.3s, color 0.3s;
      color: #ff9800;
      z-index: 2;
    }
    .switch input:checked + .slider {
      background: linear-gradient(90deg, #23242a 60%, #18191d 100%);
      justify-content: flex-end;
    }
    .switch input:checked + .slider .icon {
      color: #ffe082;
      transform: rotate(-20deg);
    }
    .slider:before {
      content: '';
      position: absolute;
      left: 4px;
      top: 4px;
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      transition: transform 0.3s, background 0.3s;
      z-index: 1;
    }
    .switch input:checked + .slider:before {
      transform: translateX(24px);
      background: #23242a;
    }
    /* Hide old icon button */
    #darkModeToggle { display: none !important; }
    /* Karaoke Decoder checkbox row styling */
    .karaoke-checkbox-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .karaoke-checkbox-row input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #ff7043;
      margin: 0;
    }
    .karaoke-checkbox-row label {
      margin: 0;
      font-weight: 500;
      color: #ff7043;
      font-size: 1.01rem;
      cursor: pointer;
    }
    /* Karaoke Decoder input/output always white */
    .karaoke-lightbox,
    .karaoke-lightbox.dark {
      background: #fff !important;
      color: #222b45 !important;
      border-color: #ffd6c2 !important;
    }
  </style>
</head>
<body>
  <div id="darkModeToggleContainer" style="position:fixed;top:24px;right:32px;z-index:1001;">
    <label class="switch">
      <input type="checkbox" id="darkModeToggleInput">
      <span class="slider">
        <span class="icon" id="darkModeIcon">☀️</span>
      </span>
    </label>
  </div>
  <div class="bg-shape1"></div>
  <div class="bg-shape2"></div>
  <div class="main-container" id="main">
    <h1 id="main-title" style="font-size:2.8rem;margin-bottom:0.5em;">Bruh subs</h1>
    <div class="subtitle" id="main-subtitle" style="margin-bottom:2.2em;">
      <span id="bruhclan-sub" style="display:block;font-size:1.35rem;color:#ff7043;font-weight:700;margin-top:0.1em;">Made by Bruh Clan</span>
    </div>
    <div id="effect-list" class="effect-list">
      <button class="effect-btn" data-tooltip="Smoothly animates text with acceleration or deceleration movement." style="font-size:1.35rem;" onclick="selectEffect('accel')">Acceleration/Deceleration Movement</button>
      <button class="effect-btn" data-tooltip="Animates each letter with a color sequence for a vibrant effect." style="font-size:1.35rem;" onclick="selectEffect('coloranim')">Letter-by-letter Color Animation</button>
      <button class="effect-btn" data-tooltip="Creates a wave-like animation across the text." style="font-size:1.35rem;" onclick="selectEffect('wave')">Wave Text Animation</button>
      <button class="effect-btn" data-tooltip="Separate karaoke timings and shows progressive syllable reveal with timings." style="font-size:1.35rem;" onclick="selectEffect('karaoke')">Karaoke Separator</button>
      <button class="effect-btn" data-tooltip="Creates progressive text reveal with bouncy poof effects on each syllable." style="font-size:1.35rem;" onclick="selectEffect('bouncyReveal')">Progressive Bouncy Reveal</button>
    </div>
    <div id="effect-ui"></div>
  </div>
  <div class="footer" id="footer" style="display:none;">Made by Bruh Clan</div>
  <div id="toast" style="display:none;position:fixed;left:50%;bottom:40px;transform:translateX(-50%);background:linear-gradient(90deg,#ff7043 60%,#ff9800 100%);color:#fff;padding:18px 36px;border-radius:16px;font-size:1.12rem;font-weight:700;box-shadow:0 2px 12px rgba(255,112,67,0.12);z-index:9999;letter-spacing:0.2px;transition:opacity 0.3s;opacity:0.98;pointer-events:none;"></div>
  <div id="outputAnim" style="display:none;position:absolute;top:30px;right:30px;font-size:2.2rem;color:#ff9800;z-index:10;"></div>
  <script>
    // Dark mode toggle
    let darkMode = false;
    function setDarkMode(on) {
      darkMode = on;
      document.body.classList.toggle('dark', on);
      document.body.classList.add('bg-fade');
      // Update switch
      const input = document.getElementById('darkModeToggleInput');
      const icon = document.getElementById('darkModeIcon');
      if (input) input.checked = on;
      if (icon) icon.textContent = on ? '🌙' : '☀️';
      // Update bg shapes
      document.querySelectorAll('.bg-shape1, .bg-shape2').forEach(el => {
        el.style.opacity = on ? 0.10 : (el.classList.contains('bg-shape1') ? 0.18 : 0.15);
      });
      // Main container and footer
      document.querySelector('.main-container').classList.toggle('dark', on);
      document.querySelector('.main-container').classList.add('bg-fade');
      document.querySelector('.footer').classList.toggle('dark', on);
      document.querySelector('.footer').classList.add('bg-fade');
      // Inputs, selects, textarea
      document.querySelectorAll('input,select,textarea').forEach(el => {
        el.classList.toggle('dark', on);
      });
      // Output textarea
      document.getElementById('output').classList.toggle('dark', on);
      // Duration bar
      document.getElementById('durationBarContainer').classList.toggle('dark', on);
      document.getElementById('resolveBarBg').classList.toggle('dark', on);
    }
    // Switch event
    document.addEventListener('DOMContentLoaded', function() {
      const input = document.getElementById('darkModeToggleInput');
      if (input) {
        input.addEventListener('change', function() {
          setDarkMode(input.checked);
        });
      }
    });
    setDarkMode(false);
    function selectEffect(effect) {
      // Hide main menu and subtitle
      document.getElementById('effect-list').style.display = 'none';
      document.getElementById('main-subtitle').style.display = 'none';
      // Show footer
      document.getElementById('footer').style.display = 'block';
      // Set effect title
      const title = document.getElementById('main-title');
      if (effect === 'accel') {
        title.textContent = 'Acceleration/Deceleration Movement';
        showAccelUI();
      } else if (effect === 'coloranim') {
        title.textContent = 'Letter-by-letter Color Animation';
        showColorAnimUI();
      } else if (effect === 'wave') {
        title.textContent = 'Wave Text Animation';
        showWaveUI();
      } else if (effect === 'karaoke') {
        title.textContent = 'Karaoke Separator';
        showKaraokeDecoderUI();
      } else if (effect === 'bouncyReveal') {
        title.textContent = 'Progressive Bouncy Reveal';
        showBouncyRevealUI();
      }
    }
    function backToMenu() {
      const mainContainer = document.querySelector('.main-container');
      mainContainer.classList.remove('slide-in');
      mainContainer.classList.add('slide-out');
      setTimeout(() => {
        // Restore the grid menu HTML
        document.getElementById('effect-list').outerHTML = `
          <div id="effect-list" class="effect-list">
            <button class="effect-btn" data-tooltip="Smoothly animates text with acceleration or deceleration movement." style="font-size:1.35rem;" onclick="selectEffect('accel')">Acceleration/Deceleration Movement</button>
            <button class="effect-btn" data-tooltip="Animates each letter with a color sequence for a vibrant effect." style="font-size:1.35rem;" onclick="selectEffect('coloranim')">Letter-by-letter Color Animation</button>
            <button class="effect-btn" data-tooltip="Creates a wave-like animation across the text." style="font-size:1.35rem;" onclick="selectEffect('wave')">Wave Text Animation</button>
            <button class="effect-btn" data-tooltip="Separate karaoke timings and shows progressive syllable reveal with timings." style="font-size:1.35rem;" onclick="selectEffect('karaoke')">Karaoke Separator</button>
            <button class="effect-btn" data-tooltip="Creates progressive text reveal with bouncy poof effects on each syllable." style="font-size:1.35rem;" onclick="selectEffect('bouncyReveal')">Progressive Bouncy Reveal</button>
          </div>
        `;
        document.getElementById('effect-ui').innerHTML = '';
        document.getElementById('main-subtitle').style.display = 'block';
        document.getElementById('footer').style.display = 'none';
        document.getElementById('main-title').textContent = 'Bruh subs';
        mainContainer.classList.remove('slide-out');
        mainContainer.classList.add('slide-in');
      }, 500);
    }
    function showAccelUI() {
      const mainContainer = document.querySelector('.main-container');
      const effectUI = document.getElementById('effect-ui');
      // Remove slide-out if present
      mainContainer.classList.remove('slide-out');
      effectUI.innerHTML = `
        <div id="errorMsg" style="display:none;color:#fff;background:#ff5252;padding:10px 18px;border-radius:8px;margin-bottom:18px;font-weight:500;"></div>
        <button class="back-btn ripple" id="backBtn">← Back</button>
        <div class="form-section">
          <label>Paste your ASS Dialogue line below:</label>
          <input id="dialogueLine" type="text" placeholder="Dialogue: 0,0:01:20.90,0:01:22.37,Romaji,,0,0,0,,{\\pos(1656,885)}Demolish this story">
          <div style="color:#ff9800;font-size:0.98rem;margin-bottom:18px;">Paste a full line from your .ass file. If it contains a {\\pos(x,y)} tag, it will be used for the start position.</div>

          <label>Start Position (e.g. {\pos(1656,885)}):</label>
          <input id="startPos" type="text" placeholder="{\pos(1656,885)}">

          <label>End Position (e.g. {\pos(961,1068)}):</label>
          <input id="endPos" type="text" placeholder="{\pos(961,1068)}">

          <label>Middle Position (optional, e.g. {\pos(1200,900)}):</label>
          <input id="midPos" type="text" placeholder="{\pos(1200,900)}">

          <label>Movement Type:</label>
          <select id="accelType">
            <option value="accel">Accelerate (speed up)</option>
            <option value="decel">Decelerate (slow down)</option>
            <option value="constant">Constant (uniform speed)</option>
          </select>

          <label>Effect Extremity:</label>
          <input id="extremity" type="range" min="1" max="5" value="2" step="0.1" oninput="document.getElementById('extremityValue').innerText = this.value">
          <span id="extremityValue" style="font-weight:500; color:#ff7043;">2</span>
          <span style="font-size:0.95rem; color:#ff9800;">(Higher = more extreme acceleration/deceleration)</span>

          <label>Custom Frame Count (optional):</label>
          <input id="customFrames" type="number" placeholder="Leave empty for auto (20ms per frame)" min="10" max="1000">
          <span style="font-size:0.95rem; color:#ff9800;">(More frames = smoother movement, especially on slower parts)</span>

          <div id="durationBarContainer" style="margin: 30px 0 18px 0;">
            <label style="display:block; margin-bottom:8px;">Effect Duration within Subtitle:</label>
            <div id="resolveBar" style="position:relative; height:38px; user-select:none;">
              <div id="resolveBarBg" style="background:#ffe0b2; border-radius:8px; height:16px; width:100%; position:absolute; top:10px;"></div>
              <div id="resolveBarEffect" style="background:#ff7043; border-radius:8px; height:16px; position:absolute; top:10px; cursor:pointer;"></div>
              <div id="effectTooltip" style="display:none; position:absolute; top:-28px; left:50%; transform:translateX(-50%); background:#ff7043; color:#fff; padding:4px 10px; border-radius:6px; font-size:0.98rem; pointer-events:none; z-index:10; box-shadow:0 2px 8px rgba(0,0,0,0.12);"></div>
              <div id="handleStart" style="position:absolute; top:4px; left:0; width:16px; height:28px; background:#fff; border:2px solid #ff7043; border-radius:6px; cursor:ew-resize; box-shadow:0 2px 8px rgba(0,0,0,0.08);"></div>
              <div id="handleEnd" style="position:absolute; top:4px; right:0; width:16px; height:28px; background:#fff; border:2px solid #ff7043; border-radius:6px; cursor:ew-resize; box-shadow:0 2px 8px rgba(0,0,0,0.08);"></div>
              <span id="barTimeStart" style="position:absolute; left:0; top:28px; font-size:0.95rem; color:#ff9800;">0.00s</span>
              <span id="barTimeEnd" style="position:absolute; right:0; top:28px; font-size:0.95rem; color:#ff9800;">0.00s</span>
            </div>
            <div id="effectDurationDisplay" style="text-align:center; margin-top:12px; color:#ff7043; font-size:1.12rem; font-weight:700; letter-spacing:0.1px;"></div>
          </div>

          <button class="generate ripple" onclick="generateAccel()" id="generateBtn">Generate</button>
          <button class="generate ripple" style="background:#ff7043;margin-top:0;position:relative;" onclick="copyOutput()" id="copyBtn">Copy to Clipboard</button>

          <label>Output:</label>
          <textarea id="output"></textarea>
        </div>
      `;
      // Animate in
      mainContainer.classList.remove('slide-in');
      void mainContainer.offsetWidth; // force reflow
      mainContainer.classList.add('slide-in');
      setupResolveBar();
      setupCurveEditor();
      // Clear error on input
      ["dialogueLine","startPos","endPos","midPos"].forEach(id => {
        document.getElementById(id).addEventListener('input', clearErrorMsg);
      });
      // Back button animation
      document.getElementById('backBtn').onclick = function(e) {
        buttonRipple(e);
        backToMenu();
      };
      // Add ripple to generate/copy
      document.getElementById('generateBtn').onclick = function(e) {
        buttonRipple(e);
        generateAccel();
      };
      document.getElementById('copyBtn').onclick = function(e) {
        buttonRipple(e);
        copyOutput();
      };
    }
    function showErrorMsg(msg) {
      const errorDiv = document.getElementById('errorMsg');
      if (errorDiv) {
        errorDiv.innerText = msg;
        errorDiv.style.display = 'block';
      }
      showToast(msg);
    }
    function showToast(msg) {
      const toast = document.getElementById('toast');
      toast.innerText = msg;
      toast.style.display = 'block';
      toast.style.opacity = '0.98';
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(()=>{toast.style.display='none';}, 400);
      }, 2200);
    }
    function clearErrorMsg() {
      const errorDiv = document.getElementById('errorMsg');
      if (errorDiv) errorDiv.style.display = 'none';
    }
    function parsePosTag(posTag) {
      // Accepts {\pos(x,y)}
      if (!posTag) return null;
      const match = posTag.match(/\\pos\((\d+),(\d+)\)/);
      if (!match) return null;
      return { x: parseInt(match[1]), y: parseInt(match[2]) };
    }
    function parseDialogueLine(line) {
      // Dialogue: 0,0:01:20.90,0:01:22.37,Romaji,,0,0,0,,{\pos(1656,885)}Demolish this story
      const parts = line.split(',');
      if (parts.length < 10) return null;
      const start = parts[1].trim();
      const end = parts[2].trim();
      const style = parts[3].trim(); // Extract the style (e.g., "Romaji")
      // Text may contain commas, so join the rest
      const text = parts.slice(9).join(',').replace(/^ */, '');
      // Try to extract {\pos(x,y)}
      let posMatch = text.match(/\\pos\((\d+),(\d+)\)/);
      let posTag = posMatch ? `{\\pos(${posMatch[1]},${posMatch[2]})}` : '';
      return { start, end, text, posTag, style };
    }
    function msToASS(ms) {
      let total = ms/1000;
      let h = Math.floor(total/3600);
      let m = Math.floor((total%3600)/60);
      let s = (total%60).toFixed(2).padStart(5,'0');
      return `${h}:${m.toString().padStart(2,'0')}:${s}`;
    }
    function setupResolveBar() {
      const dialogueInput = document.getElementById('dialogueLine');
      const barStart = document.getElementById('barTimeStart');
      const barEnd = document.getElementById('barTimeEnd');
      const bar = document.getElementById('resolveBar');
      const effectBar = document.getElementById('resolveBarEffect');
      const handleStart = document.getElementById('handleStart');
      const handleEnd = document.getElementById('handleEnd');
      const tooltip = document.getElementById('effectTooltip');
      const effectDurationDisplay = document.getElementById('effectDurationDisplay');
      let totalDuration = 0;
      let dragging = null;
      let effectStart = 0; // 0-1
      let effectEnd = 1;   // 0-1
      function updateBar() {
        const parsed = parseDialogueLine(dialogueInput.value);
        if (!parsed) {
          totalDuration = 0;
          barStart.innerText = '0.00s';
          barEnd.innerText = '0.00s';
          effectBar.style.left = '0%';
          effectBar.style.width = '100%';
          handleStart.style.left = '0%';
          handleEnd.style.left = 'calc(100% - 16px)';
          tooltip.style.display = 'none';
          effectDurationDisplay.innerText = '';
          return;
        }
        const startMS = timeToMS(parsed.start);
        const endMS = timeToMS(parsed.end);
        totalDuration = (endMS - startMS) / 1000;
        barStart.innerText = '0.00s';
        barEnd.innerText = totalDuration.toFixed(2) + 's';
        // Update effect bar and handles
        effectBar.style.left = (effectStart*100) + '%';
        effectBar.style.width = ((effectEnd-effectStart)*100) + '%';
        handleStart.style.left = `calc(${effectStart*100}% - 0px)`;
        handleEnd.style.left = `calc(${effectEnd*100}% - 16px)`;
        // Tooltip update
        const effectDurationMS = Math.round((effectEnd-effectStart) * (endMS-startMS));
        tooltip.innerText = msToASS(effectDurationMS);
        effectDurationDisplay.innerText = 'Effect Duration: ' + msToASS(effectDurationMS);
      }
      function onDrag(e, which) {
        dragging = which;
        e.preventDefault();
      }
      function onMove(e) {
        if (!dragging) return;
        const rect = bar.getBoundingClientRect();
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        let percent = Math.max(0, Math.min(1, x / rect.width));
        if (dragging === 'start') {
          effectStart = Math.min(percent, effectEnd-0.01);
        } else if (dragging === 'end') {
          effectEnd = Math.max(percent, effectStart+0.01);
        }
        updateBar();
      }
      function onUp() { dragging = null; }
      handleStart.addEventListener('mousedown', e => onDrag(e, 'start'));
      handleEnd.addEventListener('mousedown', e => onDrag(e, 'end'));
      handleStart.addEventListener('touchstart', e => onDrag(e, 'start'));
      handleEnd.addEventListener('touchstart', e => onDrag(e, 'end'));
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove);
      window.addEventListener('mouseup', onUp);
      window.addEventListener('touchend', onUp);
      dialogueInput.addEventListener('input', updateBar);
      // Tooltip show/hide and move
      effectBar.addEventListener('mouseenter', function(e) {
        tooltip.style.display = 'block';
        positionTooltip();
      });
      effectBar.addEventListener('mousemove', function(e) {
        tooltip.style.display = 'block';
        positionTooltip();
      });
      effectBar.addEventListener('mouseleave', function(e) {
        tooltip.style.display = 'none';
      });
      function positionTooltip() {
        // Center tooltip above effectBar
        const effectRect = effectBar.getBoundingClientRect();
        const barRect = bar.getBoundingClientRect();
        const left = effectRect.left - barRect.left + effectRect.width/2;
        tooltip.style.left = `${left}px`;
      }
      updateBar();
      // Save to window for generateAccel
      window._effectRange = () => [effectStart, effectEnd];
    }
    function timeToMS(time) {
      // e.g. 0:01:20.90
      let parts = time.split(':');
      let h = parseInt(parts[0]), m = parseInt(parts[1]), s = parseFloat(parts[2]);
      return Math.round((h*3600 + m*60 + s) * 1000);
    }
    function msToTime(ms) {
      let total = ms/1000;
      let h = Math.floor(total/3600);
      let m = Math.floor((total%3600)/60);
      let s = (total%60).toFixed(2);
      return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(5,'0')}`;
    }
    function setupCurveEditor() {
      const svg = document.getElementById('curveEditor');
      if (!svg) return;
      svg.innerHTML = '';
      const width = svg.clientWidth || 400;
      const height = svg.clientHeight || 200;
      // Start/end points
      let start = { x: 60, y: height-40 };
      let end = { x: width-60, y: 40 };
      // Control point (default: center, can be dragged)
      let ctrl = { x: width/2, y: height/2 };
      const ctrlDefault = { x: width/2, y: height/2 };
      // Draw function
      function draw() {
        svg.innerHTML = '';
        // Path
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', `M${start.x},${start.y} Q${ctrl.x},${ctrl.y} ${end.x},${end.y}`);
        path.setAttribute('stroke', '#ff7043');
        path.setAttribute('stroke-width', '4');
        path.setAttribute('fill', 'none');
        svg.appendChild(path);
        // Start/end dots
        [start, end].forEach(pt => {
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx', pt.x);
          c.setAttribute('cy', pt.y);
          c.setAttribute('r', 10);
          c.setAttribute('fill', '#ff9800');
          c.setAttribute('stroke', '#fff');
          c.setAttribute('stroke-width', '3');
          svg.appendChild(c);
        });
        // Control dot
        const ctrlDot = document.createElementNS('http://www.w3.org/2000/svg','circle');
        ctrlDot.setAttribute('cx', ctrl.x);
        ctrlDot.setAttribute('cy', ctrl.y);
        ctrlDot.setAttribute('r', 12);
        ctrlDot.setAttribute('fill', '#fff');
        ctrlDot.setAttribute('stroke', '#ff7043');
        ctrlDot.setAttribute('stroke-width', '4');
        ctrlDot.setAttribute('cursor', 'pointer');
        ctrlDot.setAttribute('id', 'curveCtrlDot');
        svg.appendChild(ctrlDot);
      }
      draw();
      // Drag logic
      let dragging = false;
      let dragStart = null;
      svg.addEventListener('mousedown', function(e) {
        const rect = svg.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        if (Math.hypot(mx-ctrl.x, my-ctrl.y) < 18) {
          dragging = true;
          dragStart = { x: ctrl.x, y: ctrl.y };
        }
      });
      svg.addEventListener('mousemove', function(e) {
        if (!dragging) return;
        const rect = svg.getBoundingClientRect();
        // Allow dragging anywhere within SVG, and even further outside for more curve
        ctrl.x = Math.max(-200, Math.min(width+200, e.clientX - rect.left));
        ctrl.y = Math.max(-200, Math.min(height+200, e.clientY - rect.top));
        draw();
      });
      svg.addEventListener('mouseup', function(e) {
        if (dragging) {
          // Bouncy effect
          let t = 0, startX = ctrl.x, startY = ctrl.y;
          let bounce = () => {
            t += 0.12;
            let k = Math.exp(-2*t) * Math.cos(8*t);
            ctrl.x = startX + k*4;
            ctrl.y = startY + k*4;
            draw();
            if (Math.abs(k) > 0.01) requestAnimationFrame(bounce);
          };
          bounce();
        }
        dragging = false;
      });
      svg.addEventListener('mouseleave', function(e) { dragging = false; });
      // Reset function
      window._curveEditor = {
        getCurve: () => ({ start, ctrl, end }),
        reset: () => {
          ctrl.x = ctrlDefault.x;
          ctrl.y = ctrlDefault.y;
          draw();
        }
      };
    }
    function generateAccel() {
      clearErrorMsg();
      const dialogueLine = document.getElementById('dialogueLine').value;
      const startPosTag = document.getElementById('startPos').value;
      const endPosTag = document.getElementById('endPos').value;
      const midPosTag = document.getElementById('midPos').value;
      const accelType = document.getElementById('accelType').value;
      const extremity = parseFloat(document.getElementById('extremity').value);
      const customFrames = document.getElementById('customFrames').value;
      const parsed = parseDialogueLine(dialogueLine);
      if (!parsed) {
        showErrorMsg('Invalid Dialogue line format.');
        document.getElementById('output').value = '';
        return;
      }
      const { start, end, text, style } = parsed;
      const startMS = timeToMS(start);
      const endMS = timeToMS(end);
      const duration = endMS - startMS;
      
      // Calculate frame count and timing
      let frames, frameTime;
      if (customFrames && customFrames.trim() !== '') {
        frames = parseInt(customFrames);
        frameTime = duration / frames;
      } else {
        frameTime = 20; // 20ms per frame for smoothness
        frames = Math.floor(duration / frameTime);
      }
      
      // Get effect range from bar
      let [s, e] = (window._effectRange ? window._effectRange() : [0,1]);
      let effectStartMS = startMS + Math.round(duration * s);
      let effectEndMS = startMS + Math.round(duration * e);
      
      // Parse start, middle, and end pos
      const startPos = parsePosTag(startPosTag);
      const endPos = parsePosTag(endPosTag);
      const midPos = parsePosTag(midPosTag);
      if (!startPos) {
        showErrorMsg('Invalid start position: must be in {\\pos(x,y)} format.');
        document.getElementById('output').value = '';
        return;
      }
      if (!endPos) {
        showErrorMsg('Invalid end position: must be in {\\pos(x,y)} format.');
        document.getElementById('output').value = '';
        return;
      }
      
      let output = "";
      
      // Generate frame timings with adaptive spacing for smoother movement
      let frameTimings = [];
      if (customFrames && customFrames.trim() !== '') {
        // Custom frame count: use adaptive timing for smoother movement
        for (let i = 0; i <= frames; i++) {
          let progress = i / frames;
          let t = progress;
          
          // Apply movement type to determine timing distribution
          if (accelType === "accel") {
            t = Math.pow(progress, extremity); // more frames at start (slower)
          } else if (accelType === "decel") {
            t = 1 - Math.pow(1-progress, extremity); // more frames at end (slower)
          } else if (accelType === "constant") {
            t = progress; // uniform distribution
          }
          
          let frameTime = startMS + t * duration;
          frameTimings.push(frameTime);
        }
      } else {
        // Auto timing: uniform 20ms intervals
        for (let i = 0; i <= frames; i++) {
          frameTimings.push(startMS + i * frameTime);
        }
      }
      
      for (let i = 0; i < frameTimings.length; i++) {
        let absMS = frameTimings[i];
        let progress = (absMS - effectStartMS) / (effectEndMS - effectStartMS);
        progress = Math.max(0, Math.min(1, progress));
        
        // Apply movement type
        let t = progress;
        if (accelType === "accel") {
          t = Math.pow(progress, extremity); // accelerate
        } else if (accelType === "decel") {
          t = 1 - Math.pow(1-progress, extremity); // decelerate
        } else if (accelType === "constant") {
          t = progress; // constant speed (no modification)
        }
        
        let currentX, currentY;
        if (midPos) {
          // Quadratic Bezier: start -> mid -> end
          currentX = Math.round((1-t)*(1-t)*startPos.x + 2*(1-t)*t*midPos.x + t*t*endPos.x);
          currentY = Math.round((1-t)*(1-t)*startPos.y + 2*(1-t)*t*midPos.y + t*t*endPos.y);
        } else {
          // Linear
          currentX = Math.round(startPos.x + (endPos.x-startPos.x)*t);
          currentY = Math.round(startPos.y + (endPos.y-startPos.y)*t);
        }
        
        let lineStart = msToTime(absMS);
        let lineEnd = msToTime(i < frameTimings.length - 1 ? frameTimings[i + 1] : absMS + frameTime);
        
        // Preserve original style instead of hardcoding "English"
        const originalStyle = style || "Default";
        output += `Dialogue: 0,${lineStart},${lineEnd},${originalStyle},,0,0,0,,{\\pos(${currentX},${currentY})}${text}\n`;
      }
      document.getElementById('output').value = output;
      // Animate output area
      const outputAnim = document.getElementById('outputAnim');
      const outputArea = document.getElementById('output');
      if (outputAnim) {
        outputAnim.innerHTML = '<span style="display:inline-block;transform:scale(0.7);animation:popout 0.7s cubic-bezier(.2,1.8,.5,1.1);">✔️</span>';
        outputAnim.style.display = 'block';
        setTimeout(()=>{outputAnim.style.display='none';}, 900);
      }
      if (outputArea) {
        outputArea.classList.remove('output-highlight');
        void outputArea.offsetWidth;
        outputArea.classList.add('output-highlight');
        setTimeout(()=>outputArea.classList.remove('output-highlight'), 700);
      }
    }
    function copyOutput() {
      const output = document.getElementById('output').value;
      if (!output) return;
      navigator.clipboard.writeText(output).then(() => {
        const btn = document.querySelector('button[onclick="copyOutput()"]');
        // Animate button
        btn.style.transform = 'scale(1.08)';
        setTimeout(()=>{btn.style.transform = '';}, 180);
        // Show copied animation
        let copied = document.createElement('span');
        copied.className = 'copied-anim';
        copied.innerText = 'Copied!';
        btn.parentNode.appendChild(copied);
        setTimeout(()=>{copied.remove();}, 1200);
      });
    }
    // Button ripple effect
    function buttonRipple(e) {
      const btn = e.currentTarget;
      const rect = btn.getBoundingClientRect();
      const ripple = document.createElement('span');
      ripple.className = 'ripple-effect';
      ripple.style.width = ripple.style.height = Math.max(rect.width, rect.height) + 'px';
      ripple.style.left = (e.clientX - rect.left - rect.width/2) + rect.width/2 + 'px';
      ripple.style.top = (e.clientY - rect.top - rect.height/2) + rect.height/2 + 'px';
      btn.appendChild(ripple);
      setTimeout(() => ripple.remove(), 600);
    }
    // Button ripple/scale effect
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', function(e) {
          btn.style.transform = 'scale(0.96)';
          setTimeout(()=>{btn.style.transform = '';}, 120);
        });
      });
    });
    // Output animation keyframes
    const style = document.createElement('style');
    style.innerHTML = `@keyframes popout {0%{transform:scale(0.7);} 60%{transform:scale(1.2);} 100%{transform:scale(1);}}`;
    document.head.appendChild(style);
    function showColorAnimUI() {
      const mainContainer = document.querySelector('.main-container');
      const effectUI = document.getElementById('effect-ui');
      mainContainer.classList.remove('slide-out');
      effectUI.innerHTML = `
        <div id="errorMsg" style="display:none;color:#fff;background:#ff5252;padding:10px 18px;border-radius:8px;margin-bottom:18px;font-weight:500;"></div>
        <button class="back-btn ripple" id="backBtn">← Back</button>
        <div class="form-section">
          <label>Delay between letters (ms):</label>
          <input type="number" id="delay" value="50" class="darkable">

          <label>Duration of each color (ms):</label>
          <input type="number" id="colorDuration" value="300" class="darkable">

          <label>Duration of the line (ms):</label>
          <input type="number" id="duration" value="7000" class="darkable">

          <label>Colors (comma-separated):</label>
          <input type="text" id="colors" value="red,green,blue,yellow" class="darkable">

          <label>Text to animate:</label>
          <input type="text" id="text" value="FUCK ANIPLEX" class="darkable">

          <div class="coloranim-btns">
            <button class="generate ripple" id="generateColorAnimBtn">Generate Color Animation</button>
            <button class="generate ripple" id="copyColorAnimBtn" style="background:#ff7043;position:relative;">Copy to Clipboard</button>
          </div>

          <div class="result" style="margin-top:20px;">
            <div class="coloranim-preview" id="colorAnimPreview"></div>
            <div class="coloranim-output" id="colorAnimOutput"></div>
          </div>
        </div>
      `;
      mainContainer.classList.remove('slide-in');
      void mainContainer.offsetWidth;
      mainContainer.classList.add('slide-in');
      // Back button
      document.getElementById('backBtn').onclick = function(e) {
        buttonRipple(e);
        backToMenu();
      };
      // Generate button
      document.getElementById('generateColorAnimBtn').onclick = function(e) {
        buttonRipple(e);
        generateColorAnim();
      };
      // Copy button
      document.getElementById('copyColorAnimBtn').onclick = function(e) {
        buttonRipple(e);
        copyColorAnim();
      };
    }
    function generateColorAnim() {
      const delay = parseInt(document.getElementById('delay').value);
      const colorDuration = parseInt(document.getElementById('colorDuration').value) || 300;
      const duration = parseInt(document.getElementById('duration').value);
      const colors = document.getElementById('colors').value.split(',').map(color => color.trim());
      const text = document.getElementById('text').value;
      const output = document.getElementById('colorAnimOutput');
      const preview = document.getElementById('colorAnimPreview');
      output.textContent = '';
      preview.innerHTML = '';

      let commands = '';
      text.split('').forEach((letter, index) => {
        let span = document.createElement('span');
        span.textContent = letter;
        preview.appendChild(span);
        let currentTime = 0;
        commands += `{`;
        while (currentTime < duration) {
          for (let color of colors) {
            if (currentTime >= duration) break;
            let colorStartTime = currentTime;
            let colorEndTime = Math.min(currentTime + colorDuration, duration);
            commands += `\\t(${index * delay + colorStartTime},${index * delay + colorEndTime},\\c&H${formatColor(color)}&)`;
            setTimeout(() => {
              span.style.color = color;
            }, index * delay + colorStartTime);
            currentTime += colorDuration;
          }
        }
        commands += `}${letter}`;
      });
      output.textContent = commands.trim();
      // Animate output area
      output.classList.remove('output-highlight');
      void output.offsetWidth;
      output.classList.add('output-highlight');
      setTimeout(()=>output.classList.remove('output-highlight'), 700);
    }
    function formatColor(color) {
      const hexPattern = /^&H([a-fA-F0-9]{6})&$/;
      const match = hexPattern.exec(color);
      if (match) {
        return match[1].toUpperCase();
      } else {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.fillStyle = color;
        return ctx.fillStyle.substring(1).toUpperCase();
      }
    }
    function copyColorAnim() {
      const output = document.getElementById('colorAnimOutput');
      navigator.clipboard.writeText(output.textContent)
        .then(() => {
          const btn = document.getElementById('copyColorAnimBtn');
          btn.style.transform = 'scale(1.08)';
          setTimeout(()=>{btn.style.transform = '';}, 180);
          let copied = document.createElement('span');
          copied.className = 'copied-anim';
          copied.innerText = 'Copied!';
          btn.parentNode.appendChild(copied);
          setTimeout(()=>{copied.remove();}, 1200);
        });
    }
    function showWaveUI() {
      const mainContainer = document.querySelector('.main-container');
      const effectUI = document.getElementById('effect-ui');
      mainContainer.classList.remove('slide-out');
      effectUI.innerHTML = `
        <div id="errorMsg" style="display:none;color:#fff;background:#ff5252;padding:10px 18px;border-radius:8px;margin-bottom:18px;font-weight:500;"></div>
        <button class="back-btn ripple" id="backBtn">← Back</button>
        <div class="form-section">
          <label>Paste your ASS Dialogue line:</label>
          <input id="waveLine" type="text" placeholder="Dialogue: 0,0:00:54.37,0:00:56.96,Romaji,,0,0,0,,{\pos(100,100)}Your text here">
          <label>Default Size (e.g. 20):</label>
          <input id="waveDefaultSize" type="number" value="20">
          <label>Maximum Size (e.g. 30):</label>
          <input id="waveMaxSize" type="number" value="30">
          <label>Number of Waves (how many crests will pass through, e.g. 1):</label>
          <input id="waveCount" type="number" value="1" min="1" max="10">
          <div style="color:#888;font-size:0.98em;margin-bottom:8px;">1 = one swoop, 2 = two swoops, etc.</div>
          <label>Wave Frequency (letters per wave, e.g. 6):</label>
          <input id="waveFrequency" type="number" value="6">
          <div style="color:#888;font-size:0.98em;margin-bottom:8px;">How many letters per wave crest (higher = more waves visible at once).</div>
          <div id="waveBarContainer" style="margin: 30px 0 18px 0;"></div>
          <button class="generate ripple" id="generateWaveBtn">Generate Wave Animation</button>
          <button class="generate ripple" style="background:#ff7043;position:relative;" id="copyWaveBtn">Copy to Clipboard</button>
          <label>Output:</label>
          <textarea id="waveOutput"></textarea>
        </div>
      `;
      // Setup wave window bar (like function 1)
      setupWaveBar();
      mainContainer.classList.remove('slide-in');
      void mainContainer.offsetWidth;
      mainContainer.classList.add('slide-in');
      document.getElementById('backBtn').onclick = function(e) {
        buttonRipple(e);
        backToMenu();
      };
      document.getElementById('generateWaveBtn').onclick = function(e) {
        buttonRipple(e);
        generateWaveAnim();
      };
      document.getElementById('copyWaveBtn').onclick = function(e) {
        buttonRipple(e);
        const output = document.getElementById('waveOutput').value;
        if (!output) return;
        navigator.clipboard.writeText(output).then(() => {
          const btn = document.getElementById('copyWaveBtn');
          btn.style.transform = 'scale(1.08)';
          setTimeout(()=>{btn.style.transform = '';}, 180);
          let copied = document.createElement('span');
          copied.className = 'copied-anim';
          copied.innerText = 'Copied!';
          btn.parentNode.appendChild(copied);
          setTimeout(()=>{copied.remove();}, 1200);
        });
      };
    }
    function setupWaveBar() {
      const container = document.getElementById('waveBarContainer');
      container.innerHTML = `
        <label style="display:block; margin-bottom:8px;">Wave Animation Window:</label>
        <div id="waveBar" style="position:relative; height:38px; user-select:none;">
          <div id="waveBarBg" style="background:#ffe0b2; border-radius:8px; height:16px; width:100%; position:absolute; top:10px;"></div>
          <div id="waveBarEffect" style="background:#ff7043; border-radius:8px; height:16px; position:absolute; top:10px; cursor:pointer;"></div>
          <div id="waveHandleStart" style="position:absolute; top:4px; left:0; width:16px; height:28px; background:#fff; border:2px solid #ff7043; border-radius:6px; cursor:ew-resize; box-shadow:0 2px 8px rgba(0,0,0,0.08);"></div>
          <div id="waveHandleEnd" style="position:absolute; top:4px; right:0; width:16px; height:28px; background:#fff; border:2px solid #ff7043; border-radius:6px; cursor:ew-resize; box-shadow:0 2px 8px rgba(0,0,0,0.08);"></div>
          <span id="waveBarTimeStart" style="position:absolute; left:0; top:28px; font-size:0.95rem; color:#ff9800;">0.00s</span>
          <span id="waveBarTimeEnd" style="position:absolute; right:0; top:28px; font-size:0.95rem; color:#ff9800;">0.00s</span>
        </div>
        <div id="waveWindowDisplay" style="text-align:center; margin-top:12px; color:#ff7043; font-size:1.12rem; font-weight:700; letter-spacing:0.1px;"></div>
      `;
      // Bar logic (like function 1)
      const bar = document.getElementById('waveBar');
      const effectBar = document.getElementById('waveBarEffect');
      const handleStart = document.getElementById('waveHandleStart');
      const handleEnd = document.getElementById('waveHandleEnd');
      const barStart = document.getElementById('waveBarTimeStart');
      const barEnd = document.getElementById('waveBarTimeEnd');
      const windowDisplay = document.getElementById('waveWindowDisplay');
      let totalDuration = 1;
      let effectStart = 0;
      let effectEnd = 1;
      function updateBar() {
        // Try to get duration from input
        let line = document.getElementById('waveLine').value;
        let start = 0, end = 0;
        if (line && line.startsWith('Dialogue:')) {
          let parts = line.replace(/^Dialogue: /, '').split(',');
          if (parts.length >= 3) {
            start = timeToMS(parts[1]);
            end = timeToMS(parts[2]);
          }
        }
        totalDuration = Math.max(1, end - start);
        barStart.innerText = '0.00s';
        barEnd.innerText = (totalDuration / 1000).toFixed(2) + 's';
        effectBar.style.left = (effectStart * 100) + '%';
        effectBar.style.width = ((effectEnd - effectStart) * 100) + '%';
        handleStart.style.left = `calc(${effectStart * 100}% - 0px)`;
        handleEnd.style.left = `calc(${effectEnd * 100}% - 16px)`;
        let windowMS = Math.round((effectEnd - effectStart) * totalDuration);
        windowDisplay.innerText = 'Wave Window: ' + (windowMS / 1000).toFixed(2) + 's';
      }
      let dragging = null;
      function onDrag(e, which) {
        dragging = which;
        e.preventDefault();
      }
      function onMove(e) {
        if (!dragging) return;
        const rect = bar.getBoundingClientRect();
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        let percent = Math.max(0, Math.min(1, x / rect.width));
        if (dragging === 'start') {
          effectStart = Math.min(percent, effectEnd - 0.01);
        } else if (dragging === 'end') {
          effectEnd = Math.max(percent, effectStart + 0.01);
        }
        updateBar();
      }
      function onUp() { dragging = null; }
      handleStart.addEventListener('mousedown', e => onDrag(e, 'start'));
      handleEnd.addEventListener('mousedown', e => onDrag(e, 'end'));
      handleStart.addEventListener('touchstart', e => onDrag(e, 'start'));
      handleEnd.addEventListener('touchstart', e => onDrag(e, 'end'));
      window.addEventListener('mousemove', onMove);
      window.addEventListener('touchmove', onMove);
      window.addEventListener('mouseup', onUp);
      window.addEventListener('touchend', onUp);
      document.getElementById('waveLine').addEventListener('input', updateBar);
      updateBar();
      window._waveWindow = () => [effectStart, effectEnd, totalDuration];
    }
    function generateWaveAnim() {
      clearErrorMsg();
      const line = document.getElementById('waveLine').value;
      const defaultSize = parseInt(document.getElementById('waveDefaultSize').value) || 20;
      const maxSize = parseInt(document.getElementById('waveMaxSize').value) || 30;
      const amplitude = maxSize - defaultSize;
      const waveCount = parseInt(document.getElementById('waveCount').value) || 1;
      const frequency = parseFloat(document.getElementById('waveFrequency').value) || 6;
      const outputArea = document.getElementById('waveOutput');
      outputArea.value = '';
      if (!line.startsWith('Dialogue:')) {
        showErrorMsg('Line must start with Dialogue:');
        return;
      }
      let rest = line.replace(/^Dialogue: /, '');
      const fields = [];
      for (let i = 0; i < 9; i++) {
        const idx = rest.indexOf(',');
        if (idx === -1) {
          fields.push(rest);
          rest = '';
        } else {
          fields.push(rest.slice(0, idx));
          rest = rest.slice(idx + 1);
        }
      }
      fields.push(rest); // The rest is the text
      if (fields.length < 10) {
        showErrorMsg('Invalid Dialogue line format.');
        return;
      }
      const [layer, start, end, style, name, marginL, marginR, marginV, effect, text] = fields;
      let tagMatch = text.match(/^((?:\{[^}]+\})*)/);
      let baseTags = tagMatch ? tagMatch[1] : '';
      let textWithoutTags = text.replace(/^((?:\{[^}]+\})*)/, '');
      let startTime = timeToMS(start);
      let endTime = timeToMS(end);
      let duration = endTime - startTime;
      let frameStep = 40; // ms per frame
      let chars = textWithoutTags.split('');
      let lines = [];
      // Get wave window
      let [effectStart, effectEnd, totalDuration] = window._waveWindow ? window._waveWindow() : [0, 1, duration];
      let waveStart = startTime + Math.round(totalDuration * effectStart);
      let waveEnd = startTime + Math.round(totalDuration * effectEnd);
      // Before wave: static
      if (waveStart > startTime) {
        lines.push(`Dialogue: 0,${msToTime(startTime)},${msToTime(waveStart)},${style},${name},${marginL},${marginR},${marginV},,${baseTags}${textWithoutTags}`);
      }
      // During wave: animate
      let waveDuration = waveEnd - waveStart;
      let waveFrames = Math.max(1, Math.floor(waveDuration / frameStep));
      let nextWaveStart = waveStart;
      for (let w = 0; w < waveCount; w++) {
        // For each wave, animate crest from left to right, then animate trailing falloff
        let segmentStart = nextWaveStart;
        let segmentEnd = waveStart + Math.round((w + 1) * waveDuration / waveCount);
        let segmentDuration = segmentEnd - segmentStart;
        let segmentFrames = Math.max(1, Math.floor(segmentDuration / frameStep));
        let falloffFrames = Math.ceil(frequency / 2); // Extra frames for trailing falloff
        // Animate crest moving left to right
        for (let f = 0; f < segmentFrames; f++) {
          let t = (f * frameStep);
          let time = segmentStart + f * frameStep;
          let progress = t / segmentDuration; // 0 to 1
          let crestPos = progress * (chars.length - 1);
          let frameText = '';
          for (let i = 0; i < chars.length; i++) {
            let size = defaultSize;
            let dist = Math.abs(i - crestPos);
            let falloff = 0;
            if (dist < frequency / 2) {
              falloff = 0.5 * (1 + Math.cos(Math.PI * dist / (frequency / 2)));
            }
            size = Math.round(defaultSize + amplitude * falloff);
            frameText += `{\\fs${size}}${chars[i]}{\\r}`;
          }
          lines.push(`Dialogue: 0,${msToTime(time)},${msToTime(time + frameStep)},${style},${name},${marginL},${marginR},${marginV},,${baseTags}${frameText}`);
        }
        // Animate trailing falloff after crest passes last letter
        for (let f = 1; f <= falloffFrames; f++) {
          let time = segmentEnd + (f - 1) * frameStep;
          let crestPos = (chars.length - 1) + f; // Move crest past the end
          let frameText = '';
          for (let i = 0; i < chars.length; i++) {
            let size = defaultSize;
            let dist = Math.abs(i - crestPos);
            let falloff = 0;
            if (dist < frequency / 2) {
              falloff = 0.5 * (1 + Math.cos(Math.PI * dist / (frequency / 2)));
            }
            size = Math.round(defaultSize + amplitude * falloff);
            frameText += `{\\fs${size}}${chars[i]}{\\r}`;
          }
          lines.push(`Dialogue: 0,${msToTime(time)},${msToTime(time + frameStep)},${style},${name},${marginL},${marginR},${marginV},,${baseTags}${frameText}`);
        }
        // Update nextWaveStart to be after this wave's falloff
        nextWaveStart = segmentEnd + falloffFrames * frameStep;
      }
      // After wave: static
      if (nextWaveStart < endTime) {
        lines.push(`Dialogue: 0,${msToTime(nextWaveStart)},${end},${style},${name},${marginL},${marginR},${marginV},,${baseTags}${textWithoutTags}`);
      }
      outputArea.value = lines.join('\n').replace(/\\n/g, '\n');
      // Animate output area
      outputArea.classList.remove('output-highlight');
      void outputArea.offsetWidth;
      outputArea.classList.add('output-highlight');
      setTimeout(()=>outputArea.classList.remove('output-highlight'), 700);
    }
    function showKaraokeDecoderUI() {
      const mainContainer = document.querySelector('.main-container');
      const effectUI = document.getElementById('effect-ui');
      mainContainer.classList.remove('slide-out');
      effectUI.innerHTML = `
        <div id="errorMsg" style="display:none;color:#fff;background:#ff5252;padding:10px 18px;border-radius:8px;margin-bottom:18px;font-weight:500;"></div>
        <button class="back-btn ripple" id="backBtn">← Back</button>
        <div class="form-section">
          <label>Paste your ASS Dialogue lines with {\\k} tags (one per line):</label>
          <textarea id="karaokeInput" class="karaoke-lightbox" rows="4" style="resize:vertical;min-height:60px;" placeholder="Dialogue: 0,0:01:05.03,0:01:07.52,Romaji,,0,0,0,,{\\k29}Son{\\k16}na ...\nDialogue: 0,0:01:07.52,0:01:09.00,Romaji,,0,0,0,,{\\k20}Another{\\k15}Line"></textarea>
          <div class="karaoke-checkbox-row">
            <input type="checkbox" id="karaokeCurrentOnly">
            <label for="karaokeCurrentOnly">Only show current \\k syllable</label>
          </div>
          <div class="karaoke-checkbox-row" style="align-items: center;">
            <input type="checkbox" id="karaokeBouncyPoof">
            <label for="karaokeBouncyPoof">Apply bouncy poof effect</label>
            <button id="bouncySettingsBtn" type="button" style="margin-left:4px;padding:0 2px;font-size:1em;width:22px;height:22px;min-width:0;min-height:0;line-height:20px;border:none;background:#ffe0b2;border-radius:5px;cursor:pointer;display:flex;align-items:center;justify-content:center;align-self:center;" title="Adjust bouncy poof sizes">⚙️</button>
          </div>
          <div id="bouncySettingsPanel" style="display:none;margin:6px 0 10px 0;padding:0;">
            <span style="display:inline-flex;align-items:center;gap:8px;">
              <label for="bouncyStartSize" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">Start Size:</label>
              <input type="number" id="bouncyStartSize" value="60" min="10" max="200" style="width:60px;height:32px;font-size:1.15em;padding:4px 10px;margin:0 12px 0 2px;border-radius:6px;background:#fff7f0;">
              <label for="bouncyEndSize" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">End Size:</label>
              <input type="number" id="bouncyEndSize" value="40" min="10" max="200" style="width:60px;height:32px;font-size:1.15em;padding:4px 10px;margin:0 0 0 2px;border-radius:6px;background:#fff7f0;">
            </span>
          </div>
          <div class="karaoke-checkbox-row" style="align-items: center;">
            <input type="checkbox" id="karaokeSlideEffect">
            <label for="karaokeSlideEffect">Apply slide effect to each \\k</label>
            <button id="slideSettingsBtn" type="button" style="margin-left:4px;padding:0 2px;font-size:1em;width:22px;height:22px;min-width:0;min-height:0;line-height:20px;border:none;background:#ffe0b2;border-radius:5px;cursor:pointer;display:flex;align-items:center;justify-content:center;align-self:center;" title="Adjust slide effect settings">⚙️</button>
          </div>
          <div id="slideEffectInputs" style="display:none;margin:6px 0 10px 0;padding:0;">
            <span style="display:inline-flex;align-items:center;gap:8px;">
              <label for="slideEndPos" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">Endpoint Position:</label>
              <input type="text" id="slideEndPos" placeholder="{\pos(837,506)}" style="width:110px;height:28px;font-size:1em;padding:2px 6px;margin:0 12px 0 2px;border-radius:6px;background:#fff7f0;">
              <label for="slideStartPos" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">Start Position (optional):</label>
              <input type="text" id="slideStartPos" placeholder="{\pos(837,406)}" style="width:110px;height:28px;font-size:1em;padding:2px 6px;margin:0 0 0 2px;border-radius:6px;background:#fff7f0;">
            </span>
          </div>
          <div class="karaoke-checkbox-row" style="align-items: center;">
            <input type="checkbox" id="karaokeGrapefruitEffect">
            <label for="karaokeGrapefruitEffect">Apply grapefruit effect</label>
            <button id="grapefruitSettingsBtn" type="button" style="margin-left:4px;padding:0 2px;font-size:1em;width:22px;height:22px;min-width:0;min-height:0;line-height:20px;border:none;background:#ffe0b2;border-radius:5px;cursor:pointer;display:flex;align-items:center;justify-content:center;align-self:center;" title="Adjust grapefruit effect settings">⚙️</button>
          </div>
          <div id="grapefruitEffectInputs" style="display:none;margin:6px 0 10px 0;padding:0;">
            <div style="display:flex;flex-direction:column;gap:8px;">
              <div style="display:flex;flex-direction:column;">
                <label for="grapefruitEndPos" style="font-size:0.97em;color:#ff7043;font-weight:600;margin-bottom:2px;">Endpoint Position:</label>
                <input type="text" id="grapefruitEndPos" placeholder="\\pos(960,57)" style="width:100%;height:28px;font-size:1em;padding:2px 6px;border-radius:6px;background:#fff7f0;">
              </div>
              <div style="display:flex;flex-direction:column;">
                <label for="grapefruitStartPos" style="font-size:0.97em;color:#ff7043;font-weight:600;margin-bottom:2px;">Start Position (optional):</label>
                <input type="text" id="grapefruitStartPos" placeholder="\\pos(960,157)" style="width:100%;height:28px;font-size:1em;padding:2px 6px;border-radius:6px;background:#fff7f0;">
              </div>
              <div style="display:flex;flex-direction:column;">
                <label for="grapefruitPreColor" style="font-size:0.97em;color:#ff7043;font-weight:600;margin-bottom:2px;">Pre-highlight color:</label>
                <input type="text" id="grapefruitPreColor" placeholder="\\3c&HFFFFFF&\\4c&HE8434C&\\2c&HEFD3D4&\\c&HECCFD0&" style="width:100%;height:28px;font-size:1em;padding:2px 6px;border-radius:6px;background:#fff7f0;">
              </div>
              <div style="display:flex;flex-direction:column;">
                <label for="grapefruitHighlightColor" style="font-size:0.97em;color:#ff7043;font-weight:600;margin-bottom:2px;">Highlight color:</label>
                <input type="text" id="grapefruitHighlightColor" placeholder="\\3c&HFFFFFF&\\4c&HE8434C&\\2c&HEFD3D4&\\c&HD6969A&" style="width:100%;height:28px;font-size:1em;padding:2px 6px;border-radius:6px;background:#fff7f0;">
              </div>
            </div>
          </div>
          <button class="generate ripple" id="generateKaraokeBtn">Generate Karaoke timings</button>
          <button class="generate ripple" style="background:#ff7043;position:relative;" id="copyKaraokeBtn">Copy to Clipboard</button>
          <label>Output:</label>
          <textarea id="karaokeOutput" class="karaoke-lightbox"></textarea>
          <label style="margin-top: 18px; color: #ff7043; font-weight: 700; font-size: 1.08rem; letter-spacing: 0.1px;">Karaoke Activation Times:</label>
          <div id="karaokeTimes" style="background: linear-gradient(90deg, #fff7f0 60%, #ffe0e0 100%); border-radius: 14px; padding: 18px 22px; margin-top: 10px; font-size: 1.13rem; color: #ff7043; font-family: 'Inter', Arial, sans-serif; box-shadow: 0 2px 8px rgba(255,112,67,0.08); border: 1.5px solid #ffd6c2; white-space: pre-wrap; word-break: break-all; overflow-x: auto; margin-bottom: 32px;"> </div>
        </div>
      `;
      mainContainer.classList.remove('slide-in');
      void mainContainer.offsetWidth;
      mainContainer.classList.add('slide-in');
      document.getElementById('backBtn').onclick = function(e) {
        buttonRipple(e);
        backToMenu();
      };
      document.getElementById('generateKaraokeBtn').onclick = function(e) {
        buttonRipple(e);
        generateKaraokeDecoder();
      };
      document.getElementById('copyKaraokeBtn').onclick = function(e) {
        buttonRipple(e);
        const output = document.getElementById('karaokeOutput').value;
        if (!output) return;
        navigator.clipboard.writeText(output).then(() => {
          const btn = document.getElementById('copyKaraokeBtn');
          btn.style.transform = 'scale(1.08)';
          setTimeout(()=>{btn.style.transform = '';}, 180);
          let copied = document.createElement('span');
          copied.className = 'copied-anim';
          copied.innerText = 'Copied!';
          btn.parentNode.appendChild(copied);
          setTimeout(()=>{copied.remove();}, 1200);
        });
      };
      // Bouncy settings button logic
      const bouncySettingsBtn = document.getElementById('bouncySettingsBtn');
      const bouncySettingsPanel = document.getElementById('bouncySettingsPanel');
      if (bouncySettingsBtn && bouncySettingsPanel) {
        bouncySettingsBtn.onclick = function() {
          bouncySettingsPanel.style.display = bouncySettingsPanel.style.display === 'none' ? 'block' : 'none';
        };
      }
      // Slide effect UI logic
      const slideEffectCheckbox = document.getElementById('karaokeSlideEffect');
      const slideEffectInputs = document.getElementById('slideEffectInputs');
      const slideSettingsBtn = document.getElementById('slideSettingsBtn');
      if (slideEffectCheckbox && slideEffectInputs && slideSettingsBtn) {
        slideEffectCheckbox.onchange = function() {
          if (slideEffectCheckbox.checked) {
            slideEffectInputs.style.display = 'block';
          } else {
            slideEffectInputs.style.display = 'none';
          }
        };
        slideSettingsBtn.onclick = function() {
          slideEffectInputs.style.display = (slideEffectInputs.style.display === 'none' || slideEffectInputs.style.display === '') ? 'block' : 'none';
        };
      }
      // Grapefruit effect UI logic
      const grapefruitEffectCheckbox = document.getElementById('karaokeGrapefruitEffect');
      const grapefruitEffectInputs = document.getElementById('grapefruitEffectInputs');
      const grapefruitSettingsBtn = document.getElementById('grapefruitSettingsBtn');
      if (grapefruitEffectCheckbox && grapefruitEffectInputs && grapefruitSettingsBtn) {
        grapefruitEffectCheckbox.onchange = function() {
          if (grapefruitEffectCheckbox.checked) {
            grapefruitEffectInputs.style.display = 'block';
          } else {
            grapefruitEffectInputs.style.display = 'none';
          }
        };
        grapefruitSettingsBtn.onclick = function() {
          grapefruitEffectInputs.style.display = (grapefruitEffectInputs.style.display === 'none' || grapefruitEffectInputs.style.display === '') ? 'block' : 'none';
        };
      }
    }
    function generateKaraokeDecoder() {
      clearErrorMsg();
      const input = document.getElementById('karaokeInput').value;
      const outputArea = document.getElementById('karaokeOutput');
      const timesArea = document.getElementById('karaokeTimes');
      const currentOnly = document.getElementById('karaokeCurrentOnly')?.checked;
      const bouncyPoof = document.getElementById('karaokeBouncyPoof')?.checked;
      const bouncyStartSize = parseInt(document.getElementById('bouncyStartSize')?.value) || 60;
      const bouncyEndSize = parseInt(document.getElementById('bouncyEndSize')?.value) || 40;
      const slideEffect = document.getElementById('karaokeSlideEffect')?.checked;
      const slideEndPos = document.getElementById('slideEndPos')?.value;
      const slideStartPos = document.getElementById('slideStartPos')?.value;
      const grapefruitEffect = document.getElementById('karaokeGrapefruitEffect')?.checked;
      const grapefruitEndPos = document.getElementById('grapefruitEndPos')?.value;
      const grapefruitStartPos = document.getElementById('grapefruitStartPos')?.value;
      const grapefruitPreColor = document.getElementById('grapefruitPreColor')?.value;
      const grapefruitHighlightColor = document.getElementById('grapefruitHighlightColor')?.value;
      outputArea.value = '';
      timesArea.textContent = '';
      // Support multiple lines
      const inputLines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
      let allLines = [];
      let allTimeLogs = [];
      // Helper functions
      function timeToS(t) {
        let p = t.split(':');
        return parseInt(p[0])*3600 + parseInt(p[1])*60 + parseFloat(p[2]);
      }
      function sToTime(s) {
        let h = Math.floor(s/3600);
        let m = Math.floor((s%3600)/60);
        let sec = (s%60).toFixed(2).padStart(5,'0');
        return `${h}:${m.toString().padStart(2,'0')}:${sec}`;
      }
      // Process each input line
      for (const line of inputLines) {
        const match = line.match(/^Dialogue: ([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),(.+)$/);
      if (!match) {
          allTimeLogs.push('<span style="color:#ff5252;">Invalid input: ' + line.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</span>');
          continue;
      }
      const [_, layer, start, end, style, name, marginL, marginR, marginV, effect, text] = match;
      // Extract {\kXX} and text segments
      const kRegex = /\{\\k(\d+)\}([^\{]*)/g;
      let kTags = [];
      let totalK = 0;
      let m;
      while ((m = kRegex.exec(text)) !== null) {
        kTags.push({ k: parseInt(m[1]), text: m[2] });
        totalK += parseInt(m[1]);
      }
      if (kTags.length === 0) {
          allTimeLogs.push('<span style="color:#ff5252;">No {\\k} tags found: ' + line.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</span>');
          continue;
      }
      const startS = timeToS(start);
      const endS = timeToS(end);
      const totalDuration = endS - startS;
      const unitDuration = totalK ? totalDuration / totalK : 0;
      // Precompute activation times
      let activationTimes = [startS];
      let timeLog = [];
      for (let i = 0; i < kTags.length; i++) {
        let prev = activationTimes[activationTimes.length-1];
        let duration = kTags[i].k * unitDuration;
        activationTimes.push(prev + duration);
        let logLine = `${i+1}. \\k${kTags[i].k} → ${sToTime(prev)}`;
        if (i < kTags.length - 1) logLine += ` (${(activationTimes[i+1]-activationTimes[i]).toFixed(2)}s)`;
        else logLine += ` (${(endS-activationTimes[i]).toFixed(2)}s)`;
        timeLog.push(logLine);
      }
      // Build output lines
      let lines = [];
      for (let i = 0; i < kTags.length; i++) {
        let segStart = activationTimes[i];
        let segEnd = (i === kTags.length - 1) ? endS : (activationTimes[i+1] || endS);
        // Build the text
        let displayText = '';
          // Slide effect logic
          let slideMoveTag = '';
          if (slideEffect && slideEndPos) {
            let endPos = parsePosTag(slideEndPos);
            let startPos = parsePosTag(slideStartPos);
            if (!endPos) {
              allTimeLogs.push('<span style="color:#ff5252;">Invalid endpoint position for slide effect: ' + (slideEndPos || '') + '</span>');
            } else {
              if (!startPos) {
                startPos = { x: endPos.x, y: endPos.y - 100 };
              }
              // Use \move(startX,startY,endX,endY)
              slideMoveTag = `{\\move(${startPos.x},${startPos.y},${endPos.x},${endPos.y})}`;
            }
          }
        if (currentOnly) {
          // Only current syllable visible
          for (let j = 0; j < kTags.length; j++) {
              if (j === i) {
                let t = kTags[j].text;
                if (bouncyPoof && t.trim()) {
                  let dur = (segEnd - segStart) * 1000;
                  let t1 = Math.floor(dur * 0.3);
                  let t2 = Math.floor(dur * 0.7);
                  let t3 = Math.floor(dur);
                  displayText += `{\\t(0,${t1},\\fs${bouncyStartSize}\\alpha&HFF&)\\t(${t1},${t2},\\fs${Math.round((bouncyStartSize+bouncyEndSize)/2)}\\alpha&H00&)\\t(${t2},${t3},\\fs${bouncyEndSize})}` + (slideMoveTag ? slideMoveTag : '') + t;
                } else {
                  displayText += '{\\alpha&H00&}' + (slideMoveTag ? slideMoveTag : '') + t;
                }
              } else {
                displayText += '{\\alpha&HFF&}' + kTags[j].text;
              }
          }
        } else {
          // Progressive reveal (default)
          let revealed = '', hidden = '';
          for (let j = 0; j < kTags.length; j++) {
              if (j <= i) {
                let t = kTags[j].text;
                if (bouncyPoof && t.trim()) {
                  let segS = activationTimes[j];
                  let segE = activationTimes[j+1] || endS;
                  let dur = (segE - segS) * 1000;
                  let t1 = Math.floor(dur * 0.3);
                  let t2 = Math.floor(dur * 0.7);
                  let t3 = Math.floor(dur);
                  revealed += `{\\t(0,${t1},\\fs${bouncyStartSize}\\alpha&HFF&)\\t(${t1},${t2},\\fs${Math.round((bouncyStartSize+bouncyEndSize)/2)}\\alpha&H00&)\\t(${t2},${t3},\\fs${bouncyEndSize})}` + (slideMoveTag ? slideMoveTag : '') + t;
                } else {
                  revealed += (slideMoveTag ? slideMoveTag : '') + t;
                }
              }
            else hidden += kTags[j].text;
          }
          if (revealed) displayText += '{\\alpha&H00&}' + revealed;
          if (hidden) displayText += '{\\alpha&HFF&}' + hidden;
        }
          // Grapefruit effect logic
          if (grapefruitEffect && grapefruitEndPos && grapefruitPreColor && grapefruitHighlightColor) {
            let endPos = parsePosTag(grapefruitEndPos);
            let startPos = parsePosTag(grapefruitStartPos);
            if (!endPos) {
              allTimeLogs.push('<span style="color:#ff5252;">Invalid endpoint position for grapefruit effect: ' + (grapefruitEndPos || '') + '</span>');
            } else {
              if (!startPos) {
                startPos = { x: endPos.x, y: endPos.y - 100 };
              }
              // Build for current syllable
              let before = '';
              let current = kTags[i].text;
              let after = '';
              for (let j = 0; j < kTags.length; j++) {
                if (j < i) before += kTags[j].text;
                else if (j === i) continue;
                else after += kTags[j].text;
              }
              // Line 1: moving highlight (only current syllable slides)
              let moveBlock = `\\move(${startPos.x},${startPos.y},${endPos.x},${endPos.y})`;
              let alphaBlock = '\\alpha&HFF&';
              let highlightBlock = `\\alpha&H00&${grapefruitHighlightColor}`;
              let preBlock = grapefruitPreColor;
              let line1 = `Dialogue: 0,${sToTime(segStart)},${sToTime(segEnd)},${style},${name},${marginL},${marginR},${marginV},,` +
                `{${moveBlock}${alphaBlock}${preBlock}}${before}{${highlightBlock}}${current}{\\alpha&HFF&${preBlock}}${after}`;
              // Line 2: static highlight at endpoint (all up to i highlighted, except last \k never gets highlight color)
              let posBlock = `\\pos(${endPos.x},${endPos.y})${grapefruitHighlightColor}`;
              let staticBefore = '';
              let staticAfter = '';
              if (i < kTags.length - 1) {
                // For static lines, highlight up to i-1 (delay highlight by one \k)
                for (let j = 0; j < kTags.length; j++) {
                  if (j < i) staticBefore += kTags[j].text;
                  else staticAfter += kTags[j].text;
                }
                let line2 = `Dialogue: 0,${sToTime(segStart)},${sToTime(segEnd)},${style},${name},${marginL},${marginR},${marginV},,` +
                  `{${posBlock}}${staticBefore}{${preBlock}}${staticAfter}`;
                // Push static line first, then moving line
                lines.push(line2);
                lines.push(line1);
              } else {
                // Last \k: all but last in highlight, last in pre-highlight
                let highlightPart = '';
                let prePart = '';
                for (let j = 0; j < kTags.length; j++) {
                  if (j < kTags.length - 1) highlightPart += kTags[j].text;
                  else prePart = kTags[j].text;
                }
                let line2 = `Dialogue: 0,${sToTime(segStart)},${sToTime(segEnd)},${style},${name},${marginL},${marginR},${marginV},,` +
                  `{${posBlock}}${highlightPart}{${preBlock}}${prePart}`;
                // Push static line first, then moving line
                lines.push(line2);
                lines.push(line1);
              }
              continue;
            }
          }
          let lineOut = `Dialogue: 0,${sToTime(segStart)},${sToTime(segEnd)},${style},${name},${marginL},${marginR},${marginV},,${displayText}`;
          lines.push(lineOut);
        }
        allLines.push(lines.join('\n'));
        allTimeLogs.push(timeLog.join('<br>'));
      }
      outputArea.value = allLines.join('\n');
      timesArea.innerHTML = allTimeLogs.join('<br><br>');
      // Animate output area
      outputArea.classList.remove('output-highlight');
      void outputArea.offsetWidth;
      outputArea.classList.add('output-highlight');
      setTimeout(()=>outputArea.classList.remove('output-highlight'), 700);
    }

    function showBouncyRevealUI() {
      const mainContainer = document.querySelector('.main-container');
      const effectUI = document.getElementById('effect-ui');
      mainContainer.classList.remove('slide-out');
      effectUI.innerHTML = `
        <div id="errorMsg" style="display:none;color:#fff;background:#ff5252;padding:10px 18px;border-radius:8px;margin-bottom:18px;font-weight:500;"></div>
        <button class="back-btn ripple" id="backBtn">← Back</button>
        <div class="form-section">
          <label>Paste your ASS Dialogue lines with {\\k} tags (one per line):</label>
          <textarea id="bouncyInput" class="karaoke-lightbox" rows="4" style="resize:vertical;min-height:60px;" placeholder="Dialogue: 0,0:00:50.29,0:00:52.66,Romaji,,0,0,0,,{\\k19}Ku{\\k15}ra{\\k16}i {\\k31}ton{\\k21}ne{\\k30}ru {\\k15}no {\\k34}ka{\\k56}be"></textarea>
          
          <div class="karaoke-checkbox-row" style="align-items: center;">
            <input type="checkbox" id="bouncyCustomSize" checked>
            <label for="bouncyCustomSize">Customize bouncy poof size</label>
            <button id="bouncySizeSettingsBtn" type="button" style="margin-left:4px;padding:0 2px;font-size:1em;width:22px;height:22px;min-width:0;min-height:0;line-height:20px;border:none;background:#ffe0b2;border-radius:5px;cursor:pointer;display:flex;align-items:center;justify-content:center;align-self:center;" title="Adjust bouncy poof sizes">⚙️</button>
          </div>
          
          <div id="bouncySizeSettingsPanel" style="display:none;margin:6px 0 10px 0;padding:0;">
            <span style="display:inline-flex;align-items:center;gap:8px;">
              <label for="bouncyStartSize" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">Bounce Size:</label>
              <input type="number" id="bouncyStartSize" value="40" min="10" max="200" style="width:60px;height:32px;font-size:1.15em;padding:4px 10px;margin:0 12px 0 2px;border-radius:6px;background:#fff7f0;">
              <label for="bouncyEndSize" style="font-size:0.97em;color:#ff7043;font-weight:600;margin:0 2px 0 0;">Normal Size:</label>
              <input type="number" id="bouncyEndSize" value="20" min="10" max="200" style="width:60px;height:32px;font-size:1.15em;padding:4px 10px;margin:0 0 0 2px;border-radius:6px;background:#fff7f0;">
            </span>
          </div>
          
          <div class="karaoke-checkbox-row">
            <input type="checkbox" id="bouncyShowTimings">
            <label for="bouncyShowTimings">Show syllable timing breakdown</label>
          </div>
          
          <button class="generate ripple" id="generateBouncyBtn">Generate Progressive Bouncy Reveal</button>
          <button class="generate ripple" style="background:#ff7043;position:relative;" id="copyBouncyBtn">Copy to Clipboard</button>
          
          <label>Output:</label>
          <textarea id="bouncyOutput" class="karaoke-lightbox"></textarea>
          
          <div id="bouncyTimings" style="background: linear-gradient(90deg, #fff7f0 60%, #ffe0e0 100%); border-radius: 14px; padding: 18px 22px; margin-top: 10px; font-size: 1.13rem; color: #ff7043; font-family: 'Inter', Arial, sans-serif; box-shadow: 0 2px 8px rgba(255,112,67,0.08); border: 1.5px solid #ffd6c2; white-space: pre-wrap; word-break: break-all; overflow-x: auto; margin-bottom: 32px; display: none;"> </div>
        </div>
      `;
      
      mainContainer.classList.remove('slide-in');
      void mainContainer.offsetWidth;
      mainContainer.classList.add('slide-in');
      
      // Back button
      document.getElementById('backBtn').onclick = function(e) {
        buttonRipple(e);
        backToMenu();
      };
      
      // Generate button
      document.getElementById('generateBouncyBtn').onclick = function(e) {
        buttonRipple(e);
        generateBouncyReveal();
      };
      
      // Copy button
      document.getElementById('copyBouncyBtn').onclick = function(e) {
        buttonRipple(e);
        const output = document.getElementById('bouncyOutput').value;
        if (!output) return;
        navigator.clipboard.writeText(output).then(() => {
          const btn = document.getElementById('copyBouncyBtn');
          btn.style.transform = 'scale(1.08)';
          setTimeout(()=>{btn.style.transform = '';}, 180);
          let copied = document.createElement('span');
          copied.className = 'copied-anim';
          copied.innerText = 'Copied!';
          btn.parentNode.appendChild(copied);
          setTimeout(()=>{copied.remove();}, 1200);
        });
      };
      
      // Bouncy size settings button logic
      const bouncySizeSettingsBtn = document.getElementById('bouncySizeSettingsBtn');
      const bouncySizeSettingsPanel = document.getElementById('bouncySizeSettingsPanel');
      const bouncyCustomSize = document.getElementById('bouncyCustomSize');
      
      if (bouncySizeSettingsBtn && bouncySizeSettingsPanel && bouncyCustomSize) {
        bouncySizeSettingsBtn.onclick = function() {
          bouncySizeSettingsPanel.style.display = bouncySizeSettingsPanel.style.display === 'none' ? 'block' : 'none';
        };
        
        bouncyCustomSize.onchange = function() {
          bouncySizeSettingsPanel.style.display = bouncyCustomSize.checked ? 'block' : 'none';
        };
      }
    }

    function generateBouncyReveal() {
      clearErrorMsg();
      const input = document.getElementById('bouncyInput').value;
      const outputArea = document.getElementById('bouncyOutput');
      const timingsArea = document.getElementById('bouncyTimings');
      const finalEffect = document.getElementById('bouncyFinalEffect')?.checked;
      const customSize = document.getElementById('bouncyCustomSize')?.checked;
      const bouncyStartSize = parseInt(document.getElementById('bouncyStartSize')?.value) || 40;
      const bouncyEndSize = parseInt(document.getElementById('bouncyEndSize')?.value) || 20;
      const showTimings = document.getElementById('bouncyShowTimings')?.checked;
      
      outputArea.value = '';
      timingsArea.textContent = '';
      timingsArea.style.display = showTimings ? 'block' : 'none';
      
      // Support multiple lines
      const inputLines = input.split(/\r?\n/).filter(line => line.trim().length > 0);
      let allLines = [];
      let allTimeLogs = [];
      
      // Helper functions (reused from karaoke)
      function timeToS(t) {
        let p = t.split(':');
        return parseInt(p[0])*3600 + parseInt(p[1])*60 + parseFloat(p[2]);
      }
      function sToTime(s) {
        let h = Math.floor(s/3600);
        let m = Math.floor((s%3600)/60);
        let sec = (s%60).toFixed(2).padStart(5,'0');
        return `${h}:${m.toString().padStart(2,'0')}:${sec}`;
      }
      
      // Process each input line
      for (const line of inputLines) {
        const match = line.match(/^Dialogue: ([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),(.+)$/);
        if (!match) {
          allTimeLogs.push('<span style="color:#ff5252;">Invalid input: ' + line.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</span>');
          continue;
        }
        
        const [_, layer, start, end, style, name, marginL, marginR, marginV, effect, text] = match;
        
        // Extract {\\kXX} and text segments
        const kRegex = /\\k(\d+)([^\\]*)/g;
        let kTags = [];
        let totalK = 0;
        let m;
        while ((m = kRegex.exec(text)) !== null) {
          kTags.push({ k: parseInt(m[1]), text: m[2] });
          totalK += parseInt(m[1]);
        }
        
        if (kTags.length === 0) {
          allTimeLogs.push('<span style="color:#ff5252;">No \\k tags found: ' + line.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</span>');
          continue;
        }
        
        const startS = timeToS(start);
        const endS = timeToS(end);
        const totalDuration = endS - startS;
        const unitDuration = totalK ? totalDuration / totalK : 0;
        
        // Precompute activation times
        let activationTimes = [startS];
        let timeLog = [];
        for (let i = 0; i < kTags.length; i++) {
          let prev = activationTimes[activationTimes.length-1];
          let duration = kTags[i].k * unitDuration;
          activationTimes.push(prev + duration);
          let logLine = `${i+1}. \\k${kTags[i].k} "${kTags[i].text}" → ${sToTime(prev)}`;
          if (i < kTags.length - 1) logLine += ` (${(activationTimes[i+1]-activationTimes[i]).toFixed(2)}s)`;
          else logLine += ` (${(endS-activationTimes[i]).toFixed(2)}s)`;
          timeLog.push(logLine);
        }
        
                 // Build progressive bouncy reveal lines
         let lines = [];
         
         // Helper: clean up extra override blocks
         function cleanASS(line) {
           return line
             // Remove all empty override blocks with or without whitespace
             .replace(/\{\s*\}/g, '')
             // Remove override blocks that only contain backslashes or resets
             .replace(/\{\\[a-zA-Z]*\}/g, '')
             // Remove override blocks that only contain resets and alpha
             .replace(/\{\\r(\\alpha&HFF&)?\}/g, '')
             // Remove consecutive override blocks
             .replace(/(\}\{)+/g, '}{')
             // Remove any leftover empty override blocks again
             .replace(/\{\s*\}/g, ''); // FINAL: remove any empty override block
         }
         
         // Phase 1: Initial state - all syllables hidden
         lines.push(cleanASS(`Dialogue: 0,${sToTime(startS)},${sToTime(activationTimes[1] || endS)},${style},${name},${marginL},${marginR},${marginV},,{\\alpha&HFF&}${text.replace(/\\k\d+/g, '')}`));
         
         // Phase 2: Progressive reveal with bouncy poof
         for (let i = 0; i < kTags.length; i++) {
           let segStart = activationTimes[i];
           let segEnd = (i === kTags.length - 1) ? endS : (activationTimes[i+1] || endS);
           let segDuration = (segEnd - segStart) * 1000; // Convert to ms
           
           // Calculate timing for this syllable's bounce effect
           let bounceStart = Math.floor(segDuration * 0.1); // Start bounce at 10%
           let bouncePeak = Math.floor(segDuration * 0.3);  // Peak at 30%
           let bounceEnd = Math.floor(segDuration * 0.7);   // End bounce at 70%
           
           // Line 1: Current syllable bounces, next syllable reset, rest hidden
           let bounceText = '';
           for (let j = 0; j < kTags.length; j++) {
             if (j < i) {
               // Already revealed syllables (normal)
               bounceText += kTags[j].text;
             } else if (j === i) {
               // Current syllable with bounce effect
               let currentText = kTags[j].text;
               if (customSize && currentText.trim()) {
                 bounceText += `{\\fs${bouncyStartSize}}${currentText}`;
               } else {
                 bounceText += `{\\fs40}${currentText}`;
               }
             } else if (j === i + 1) {
               // Next syllable gets reset
               bounceText += `{\\r\\alpha&HFF&}${kTags[j].text}`;
             } else {
               // Future syllables (hidden)
               bounceText += `{\\alpha&HFF&}${kTags[j].text}`;
             }
           }
           lines.push(cleanASS(`Dialogue: 0,${sToTime(segStart)},${sToTime(segStart + 0.02)},${style},${name},${marginL},${marginR},${marginV},,${bounceText}`));
           
           // Line 2: Current syllable normal, next syllable hidden, rest hidden
           let normalText = '';
           for (let j = 0; j < kTags.length; j++) {
             if (j < i) {
               // Already revealed syllables (normal)
               normalText += kTags[j].text;
             } else if (j === i) {
               // Current syllable normal
               normalText += kTags[j].text;
             } else {
               // Future syllables (hidden)
               normalText += `{\\alpha&HFF&}${kTags[j].text}`;
             }
           }
           lines.push(cleanASS(`Dialogue: 0,${sToTime(segStart + 0.02)},${sToTime(segEnd)},${style},${name},${marginL},${marginR},${marginV},,${normalText}`));
         }
        
        // Phase 3: Final bounce effect on entire text (always enabled now)
        let finalStart = activationTimes[kTags.length - 1];
        let finalEnd = endS;
        let finalDuration = (finalEnd - finalStart) * 1000;
        
        let finalBounceStart = Math.floor(finalDuration * 0.1);
        let finalBouncePeak = Math.floor(finalDuration * 0.3);
        let finalBounceEnd = Math.floor(finalDuration * 0.7);
        
        let finalText = text.replace(/\\k\d+/g, '');
        if (customSize) {
          finalText = `{\\t(0,${finalBounceStart},\\fs${bouncyEndSize})\\t(${finalBounceStart},${finalBouncePeak},\\fs${bouncyStartSize})\\t(${finalBouncePeak},${finalBounceEnd},\\fs${bouncyEndSize})}${finalText}`;
        } else {
          finalText = `{\\t(0,${finalBounceStart},\\fs${bouncyEndSize})\\t(${finalBounceStart},${finalBouncePeak},\\fs40)\\t(${finalBouncePeak},${finalBounceEnd},\\fs${bouncyEndSize})}${finalText}`;
        }
        
        lines.push(`Dialogue: 0,${sToTime(finalStart)},${sToTime(finalEnd)},${style},${name},${marginL},${marginR},${marginV},,${finalText}`);
        
        // GHOST CLEANUP: Hide all text for a short duration after the last effect line
        let ghostCleanupStart = endS;
        let ghostCleanupEnd = endS + 0.01; // 10ms after end
        let hiddenText = text.replace(/\\k\d+/g, '');
        lines.push(`Dialogue: 0,${sToTime(ghostCleanupStart)},${sToTime(ghostCleanupEnd)},${style},${name},${marginL},${marginR},${marginV},,{\\alpha&HFF&}${hiddenText}`);
        
        // Remove any plain static lines from the effect period
        lines = lines.filter(line => /\\[a-zA-Z]/.test(line));
        // After all effect lines, find the latest end time
        let effectEnd = Math.max(...lines.map(line => {
          let match = line.match(/Dialogue: 0,[^,]*,([^,]*)/);
          return match ? timeToS(match[1]) : 0;
        }));
        // If there is remaining time after the last effect, add a plain static line to fill it
        if (effectEnd < endS) {
          lines.push(`Dialogue: 0,${sToTime(effectEnd)},${sToTime(endS)},${style},${name},${marginL},${marginR},${marginV},,${hiddenText}`);
        }
        allLines.push(lines.join('\n'));
        allTimeLogs.push(timeLog.join('<br>'));
      }
      
      outputArea.value = allLines.join('\n');
      timingsArea.innerHTML = allTimeLogs.join('<br><br>');
      
      // FINAL CLEANUP: Remove any stray {} from the entire output
      outputArea.value = outputArea.value.replace(/\{\s*\}/g, '');

      // FINAL BRACE CLEANUP: Collapse multiple braces and remove unmatched braces
      function finalBraceCleanup(text) {
        // Collapse multiple opening braces
        text = text.replace(/\{+/g, '{');
        // Collapse multiple closing braces
        text = text.replace(/\}+/g, '}');
        // Remove unmatched braces
        let result = '';
        let openCount = 0;
        for (let i = 0; i < text.length; i++) {
          if (text[i] === '{') {
            // Check if there is a closing } ahead
            let closeIdx = text.indexOf('}', i);
            if (closeIdx === -1) continue; // skip this {, no matching }
            openCount++;
            result += '{';
          } else if (text[i] === '}') {
            if (openCount > 0) {
              openCount--;
              result += '}';
            }
            // else: skip this }, it's unmatched
          } else {
            result += text[i];
          }
        }
        return result;
      }
      outputArea.value = finalBraceCleanup(outputArea.value);
    }
  </script>
</body>
</html>
